## [01장] 리액트 개발을 위해 꼭 알아야 할 자바스크립트

### 리액트 컴포넌트의 렌더링 판별 여부

리액트 컴포넌트가 렌더링되는 이유 중 하나는 props의 값이 변경될 때이다. 이때 렌더링은 객체의 **얕은 비교(shallow comparison)** 를 통해 이루어지며 랜더링 여부를 포함한 변수나 함수의 메모이제이션 등 모든 작업의 동등 비교는 자바스크립의 **동등 비교**를 기반으로 한다.

### 자바스크립트의 데이터 타입

- 원시 타입

  - boolean: 참(true)과 거짓(false)만을 가질 수 있는 데이터 타입
  - null: 아직 값이 없거나 비어 있음을 명시하는 표현
  - undefined: 선언 후 값을 할당하지 않은 변수, 값이 주어지지 않은 인수에 자동으로 할당되는 값
  - number: 정수와 실수를 모두 포함하는 숫자 타입
  - string: 텍스트 타입의 데이터를 저장
  - symbol: 중복되지 않는 고유한 값 생성
  - bigint: number보다 더 큰 범위의 숫자 저장할 수 있게 함

- 객체 타입
  - object
    - 배열, 함수, 정규식, 클래스 등이 포함
    - 참조를 전달하여 ‘**참조 타입(reference type)**’이라고도 불린다.

### 값을 저장하는 방식의 차이

> 원시 타입은 불변 형태의 값으로 저장되고 객체 타입은 참조 값이 저장되므로 객체 값을 복사 시에는 참조를 복사하여 내부의 값이 갔더라도 true를 반환하지 않는다.

- 원시 타입

  - **불변값**으로, 변수 할당 시점에 메모리 영역에 저장
  - **값을 비교**

    ```tsx
    let hello = 'hello world';
    let hi = 'hello world';

    console.log(hello === hi); // true
    ```

- 객체 타입

  - **가변값**으로 참조를 저장
  - **참조를 비교**

    ```tsx
    const hello = {
      greet: 'hello',
    };

    const hi = {
      greet: 'hello',
    };

    console.log(hello === hi); // false
    console.log(hello.greet === hi.greet); // true
    ```

<br />

### Object.is

- ES6에서 새롭게 도입된 비교 문법
- `==`와 동등 비교 `===`가 만족하지 못하는 특이 케이스까지 보안하여 비교하는 장점을 가짐

  - Object.is와 ==
    ```tsx
    5 == '5'; // true
    Object.is(5, '5'); // false
    ```
  - Object.is와 ===

    ```tsx
    -0 === +0; // true
    Object.is(-0, +0); // false

    Number.NaN === NaN; // false
    Object.is(Number.NaN, NaN); // true

    NaN === 0 / 0; // false
    Object.is(NaN, 0 / 0); // true
    ```

- 단 객체 비 간 비교에 있어서는 자바스크립트 특징 상 `===` 와 동일하게 동작한다.

### 함수

- 함수란 작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감싼 실행 단위
- 리액트의 컴포넌트도 일반 함수처럼 props 객체를 매개변수로 받고, return 문으로 JSX를 반환한다. 함수형 컴포넌트는 JSX 형태로 호출한다.

- **함수 선언문 (Function Declaration)**
  - 함수 선언문은 function 키워드를 사용하여 함수를 정의한다.
  - 함수 선언문은 호이스팅(hoisting)이 발생하며, 이를 통해 코드의 어디에서나 호출할 수 있다.

```ts
hello(); //hello

function hello() {
  console.log('hello');
}

hello(); //hello
```

- **함수 표현식 (Function Expression)**
  - 함수 표현식은 함수를 변수에 할당하는 방식으로 정의합니다.
  - 변수에 할당되는 값이 함수가 된다. -함수 표현식은 선언된 위치 이후부터 호출할 수 있다.

```ts
console.log(typeof hello === 'undefined'); // true

hello(); //uncaught TypeError: hello is not a function

var hello = function () {
  console.log('hello');
};
```

- 주요 차이는 함수 선언문이 호이스팅되어 함수 정의가 스코프 최상단으로 끌어올려지지만, 함수 표현식은 변수 선언과 초기화가 동시에 이루어지므로 호이스팅되지 않는다. 따라서 함수가 선언된 이후부터 해당 변수(함수)를 사용할 수 있다.

- 함수를 만들땐 부수 효과를 최대한 억제해서 사용할 것

  - 되도록 부수 효과가 없는 순수 함수를 작성하여 사용하자. (리엑트의 관점에서는 useEffect의 작동을 최소화)

- 함수를 만들땐 가능한 작게 만들것
  - 함수 내 코드의 길이거 길어질수록 코드 스멜이 날 확률이 커지고, 함수가 정확히 무슨 역할 하는지, 내부에서 무슨 일이 일어나는지에 대한 추적이 어려워진다. 따라서 이러한 일들을 방지하기 위해선 하나의 함수에 너무 많은 동작을 담는것을 피하는 것이 좋다. ([단일 책임 원칙](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-SRP-%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99)을 준수하는 것도 좋은 방법)

### 클래스

> 리액트의 **클래스형 컴포넌트**를 이해하기 위해서는 **자바스크립트의 클래스, 프로토타입, this**를 이해해야 한다.

과거에 작성된 리액트 코드를 읽고, 함수형으로 개선하기 위해서는 자바스크립트 클래스의 동작 방식을 이해해야 한다. 이를 통해 리액트가 왜 함수형으로 패러다임을 변경했는지 알고, 클래스의 기반인 프로토타입에 대해서도 알 수 있다.

<br />

**클래스란 무엇인가?**

- 자바스크립트의 클래스란 **특정한 객체를 만들기 위한 템플릿**과 같은 개념이다.

```tsx
class Car {
  // 객체 초기화
  constructor(name) {
    this.name = name;
  }

  honk() {
    console.log(`${this.name} : 빵빵!`);
  }

  static hello() {
    console.log('안녕하세요 저는 자동차입니다');
  }

  // setter
  set age(value) {
    this.carAge = value;
  }

  // getter
  get age() {
    return this.carAge;
  }
}

const myCar = new Car('자동차');

myCar.honk(); // 자동차 : 빵빵!
Car.hello(); // 안녕하세요 저는 자동차입니다

myCar.carAge = 10;
console.log(myCar.carAge); // 10
```

> **constructor**

- 생성자: 객체를 생성하는 데 사용하는 특수한 메서드로 하나만 존재해야 한다.

> **프로퍼티**

- 클래스로 **인스턴스를 생성할 때 내부에 정의할 수 있는 속성값**을 의미

  ```tsx
  class Car {
    // 인수를 받아 객체 초기화
    constructor(name) {
      this.name = name;
    }
  }

  const myCar = new Car('자동차');
  ```

  - `#name` 처럼 private 선언할 수 있고, 타입스크립트를 활용하면 private, protected, public을 사용할 수 있다.

- **getter와 setter**
  - getter는 값을 가져올 때, setter는 클래스 필드에 값을 할당할 때 사용.
- **인스턴스 메서드(=프로토타입 메서드)**

  ```tsx
  Object.getPrototypeOf(myCar); // {constructor: ƒ, honk: ƒ}

  Object.getPrototypeOf(myCar) === Car.prototype; // true
  myCar.__proto__ === Car.prototype; // true
  ```

  - 클래스 내부에서 선언한 메서드

  - 자바스크립트의 **prototype에 선언되므로 클래스로 생성한 인스턴스에서 사용**할 수 있다.

  - **직접 객체에 선언하지 않았음에도 프로토타입에 있는 메서드를 찾아 실행**하는 것을 **프로토타입 체이닝**이라고 한다.

    - 모든 객체는 프로토타입을 가지고 있는데, 특정 속성을 찾을 때 자기 자신부터 시작해 최상위 객체인 Object의 프로토타입까지 확인한다.

- **정적 메서드**

  - 클래스 이름으로 호출할 수 있는 메서드

  - this가 클래스 자신을 가리키므로 인스턴스에 접근할 수 없지만, 인스턴스를 생성하지 않아도 사용할 수 있기 때문에 여러 곳에서 재사용 가능

  - 주로 **애플리케이션 전역에서 사용하는 유틸 함수**를 정적 메서드로 많이 활용

- **상속**

  - **A extends B:** 기존 클래스 B를 상속받아 자식 클래스 A에서 확장하여 사용
  - 상속 받은 자식 클래스는 따로 정의하지 않아도 부모 클래스의 메서드를 사용할 수 있다.

    ```tsx
    class Truck extends Car {
      constructor(name) {
        super(name);
      }

      load() {
        console.log('짐을 싣는중...');
      }
    }

    const truck = new Truck('트럭');
    truck.honk(); // 트럭 : 빵빵! - 부모 요소에서 정의한 메서드
    truck.load(); // 짐을 싣는중...
    ```

<br />

> **클래스와 함수의 관계**

- ES6 이전에는 프로토타입을 활용해 클래스의 작동 방식을 동일하게 구현하였다. 즉, **클래스는 자바스크립트의 프로토타입을 기반으로 동작**한다.

- 클래스는 객체 지향 언어를 사용하던 다른 프로그래머가 자바스크립트에 접근하기 쉽게 만들어주는 일종의 문법적 설탕 역할이다.

### 클로저

### 클로저

자바스크립트에서 클로저는 함수와 그 함수가 선언된 **렉시컬 환경**과의 조합을 의미한다. 클로저는 내부 함수가 외부 함수의 스코프에 있는 변수에 접근할 수 있게 해주며, 외부 함수의 실행이 끝난 후에도 외부 함수의 변수에 접근할 수 있게 한다. 이는 데이터 캡슐화와 정보 은닉을 구현할 때 유용하게 사용된다.

```jsx
function outerFunction() {
  const a = 8;

  function innerFunction() {
    // 내부 함수에서 외부 함수 스코프에 있는 변수에 접근 가능하다.
    console.log(a); // 8
  }

  return innerFunction;
}
```

<br/>

> **클로저의 장점**

- `데이터의 캡슐화와 정보 은닉`
  - 특정 함수에 대한 접근 권한을 제한할 수 있으며, 전역 변수의 사용을 줄여 충돌을 방지할 수 있다.
- `상태 유지`
  - 외부 함수의 상태를 내부 함수가 호출될 때마다 유지할 수 있게 해준다.

<br/>

> **클로저의 단점**

- `메모리 사용`
  - 클로저는 선언될 따마다 그 선언적 환경을 기억해야하므로 이 변수들은 가비지 컬렉션의 대상이 되지 않아 메모리 사용이 증가할 수 있다.

<br/>

### 스코프

### 리액트에서의 클로저 활용

Q. 🤔 useState 함수 호출은 한 줄로 종료되는데, setState는 useState 내부의 최신 값을 어떻게 계속 확인할 수 있을까?

A. ✅ useState 호출이 완료되어도, 해당 호출이 선언된 외부 함수가 자신이 선언된 환경 (state가 저장된 곳)을 기억하기 때문에, state 값을 계속해서 사용할 수 있다.

```jsx
function Component() {
	const [state, setState] = useState()

	fucntion handleClick() {
		// 클로저를 활용하여, setState는 계속 내부의 최신값(prev)을 알고 있다.
		setState((prev) => prev + 1)
	}
}
```

### 이벤트 루프

이벤트 루프는 `호출 스택`, `이벤트 큐`, `백그라운드 태스크` 등 여러 구성 요소를 통해 싱글 스레드 환경에서 비동기 작업을 가능하게 하는 장치다.

<br/>

> **호출 스택 (Call Stack)**

- 자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택이다.
- 함수가 호출되면 스택에 추가되고, 실행이 완료되면 제거된다.

<br/>

> **태스크 큐 (이벤트 큐)**

- 태스크 큐는 완료된 백그라운드 태스크의 콜백 함수들이 실행을 기다리는 대기열이다. 여기서 태스크는 비동기 함수의 콜백 함수나 이벤트 핸들러 등을 의미한다.
- 호출 스택이 비어 있을 때, 이벤트 루프는 태스크 큐에서 대기 중인 콜백 함수를 호출 스택으로 이동시켜 실행한다. 이 과정은 태스크 큐가 비워질 때까지 반복된다.

<br/>

> **마이크로 태스크 큐**

- 이 큐는 프로미스와 같은 마이크로 태스크를 처리한다. 태스크 큐와는 별도로 관리되며, 이벤트 루프가 태스크 큐의 태스크를 처리하기 전에 **마이크로태스크 큐의 모든 작업을 우선적으로 처리**한다.
- 작업 순서는 마이크로 태스크큐 → 렌더링 → 태스크 큐 순서이다.

<br/>

### 타입스크립트

타입스크립트는 자바스크립트의 모든 기능을 포함하며, 그 위에 정적 타입 검사와 같은 추가 기능을 제공한다.

자바스크립트는 동적 타입 언어로 변수의 타입이 런타임에 결정된다. 반면에 타입스크립트는 런타임이 아닌 빌드 타임에 이러한 타입 체크를 수행할 수 있게 해주어 에러를 예방할 수 있다.

### 타입스크립트 활용법

> `any` 대신 `unknown` 사용

- `any`는 타입스크립트의 타입 검사 시스템을 무시한다. 즉, 타입 체크를 하지 않는다. 이는 런타임에 예상치 못한 에러를 발생시킬 위험이 높다.
- `unknown` 타입은 any와 마찬가지로 어떤 종류의 값이든 할당할 수 있다. 하지만 `unknown` 타입 변수를 사용하기 전에 해당 변수의 타입을 확인하는 과정이 필요하다. 즉, 타입 가드나 타입 단언을 사용하여 해당 변수의 실제 타입을 좁혀나가야 한다.
- 이러한 특성 때문에 `unknown` 타입은 타입 안전성을 유지하면서도 유연성을 제공한다.

  ```jsx
  function doSomething(callback: unknown) {
    if (typeof callback === 'function') {
      callback();
    }
  }
  ```

<br/>

> **never 타입**

- `never` 타입은 어떤 타입도 할당될 수 없음을 나타낸다. 코드의 특정 부분이 절대 실행되지 않아야 함을 명시적으로 나타낼 수 있다.

  ```jsx
  function processEmptyObject(obj: Record<string, never>) {
    // 여기서 obj는 어떤 속성도 가지지 않는 객체여야 한다.
    console.log(obj);
  }

  processEmptyObject({}); // 성공: 비어 있는 객체
  processEmptyObject({ key: 'value' }); // 타입 에러: 'key' 속성이 있기 때문에 실패
  ```

<br/>
